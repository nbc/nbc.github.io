[
  {
    "objectID": "links.html",
    "href": "links.html",
    "title": "Quelques liens",
    "section": "",
    "text": "Quelques liens en vracs :"
  },
  {
    "objectID": "links.html#sur-r",
    "href": "links.html#sur-r",
    "title": "Quelques liens",
    "section": "sur R",
    "text": "sur R\n\nle blog de Danielle Navarro qui m’a fait découvrir Rarrow et parquet\nl’aggrégateur R bloggers avec beaucoup de ressources\nla documentation utilitR 1\nles formations R des ministères de la transition écologique 2"
  },
  {
    "objectID": "links.html#sur-duckdb",
    "href": "links.html#sur-duckdb",
    "title": "Quelques liens",
    "section": "sur duckdb",
    "text": "sur duckdb\n\nl’article de Éric Mauvière qui m’a fait découvrir l’extension spatial\nle blog de duckdb : beaucoup d’informations sur les entrailles de duckdb"
  },
  {
    "objectID": "links.html#sur-geoparquet",
    "href": "links.html#sur-geoparquet",
    "title": "Quelques liens",
    "section": "sur geoparquet",
    "text": "sur geoparquet\n\nle blog de Chris Holmes"
  },
  {
    "objectID": "links.html#footnotes",
    "href": "links.html#footnotes",
    "title": "Quelques liens",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\ndocumentation à laquelle j’ai modestement participé sur les chapitres duckdb et arrow et parquet↩︎\nJe travaille ici↩︎"
  },
  {
    "objectID": "posts/2025-07-10-benchmark/index.html",
    "href": "posts/2025-07-10-benchmark/index.html",
    "title": "Comparer des performances DuckDB/arrow",
    "section": "",
    "text": "Quand il s’agit de comparer des façons de faire, l’idéal est de lancer le code dans des outils de benchmarks mais les outils “classiques” de R ne sont pas adaptés à la comparaison de code duckdb et/ou arrow :\n\ntictoc ne retourne que le temps\nbench ne voit pas les allocations mémoires de duckdb et arrow\n…\n\nDans mes articles, j’utiliserais régulièrement timemoir écrit exprès pour ce genre de comparatifs :\n\nlibrary(timemoir)\n\ntest_function &lt;- function(n) {\n  x &lt;- rnorm(n); mean(x)\n}\n\nres &lt;- timemoir(\n  test_function(1.2e7),\n  test_function(4e7),\n  test_function(1e8)\n)\nres |&gt; \n  kableExtra::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nfname\nduration\nerror\nstart_mem\nmax_mem\ncpu_user\ncpu_sys\n\n\n\n\ntest_function(1.2e+07)\n0.666\nNA\n110088\n200888\n0.619\n0.048\n\n\ntest_function(4e+07)\n1.979\nNA\n110088\n423768\n1.861\n0.116\n\n\ntest_function(1e+08)\n3.376\nNA\n109364\n892536\n3.239\n0.136\n\n\n\n\nplot(res)\n\n\n\n\n\n\n\n\n\nCela dit il ne s’agit pas de “vrais” benchmarks rigoureux, bien au delà des objectifs de ce blog mais de comparaisons rapides, destinées à se faire une idée approximative des performances relatives.\n\n\n\n\n\n\nInformation de session\n\n\n\n\n\n\ndevtools::session_info(pkgs = \"attached\")\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.0 (2025-04-11)\n os       Ubuntu 22.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Etc/UTC\n date     2025-07-14\n pandoc   3.7.0.2 @ /usr/bin/ (via rmarkdown)\n quarto   1.7.31 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package  * version    date (UTC) lib source\n timemoir * 0.7.0.9000 2025-07-14 [1] Github (nbc/timemoir@01b6674)\n\n [1] /usr/local/lib/R/site-library\n [2] /usr/local/lib/R/library\n * ── Packages attached to the search path.\n\n──────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n\n\n\n Retour au sommet"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog",
    "section": "",
    "text": "de duckdb à st_to_sf\n\n\n\nR\n\nduckdb\n\narrow\n\nsf\n\ngeoarrow\n\n\n\nComment convertir une extraction de duckdb en objet sf\n\n\n\n\n\n12 juil. 2025\n\n\nNicolas Chuche\n\n\n\n\n\n\n\n\n\n\n\n\nComparaison entre arrow::to_arrow() et duckplyr pour écrire du parquet\n\n\n\nR\n\nduckdb\n\narrow\n\n\n\nPourquoi éviter arrow::to_arrow() avec DuckDB + dplyr\n\n\n\n\n\n11 juil. 2025\n\n\nNicolas Chuche\n\n\n\n\n\n\n\n\n\n\n\n\nComparer des performances DuckDB/arrow\n\n\n\nR\n\nbenchmark\n\n\n\nComment évaluer la mémoire et le CPU de traitements long en duckdb/arrow\n\n\n\n\n\n10 juil. 2025\n\n\nNicolas Chuche\n\n\n\n\n\nAucun article correspondant\n Retour au sommet"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Duckdb, R et autres",
    "section": "",
    "text": "Je ne suis pas statisticien mais en tant qu’informaticien, une (trop petite) partie de mon boulot est d’en aider à traiter des données relativement massives.\nCe site me sert à partager les trucs intéressants que j’ai découvert dans ce cadre ou à travers mes lectures. Ça parlera pas mal de R et de duckdb mais pas que.\nAucune garantie de régularité ni d’exactitude.\nPour le moment tout se passe dans la section blog.\n\n\n\n Retour au sommet"
  },
  {
    "objectID": "posts/2025-07-10-st_as_sf/index.html",
    "href": "posts/2025-07-10-st_as_sf/index.html",
    "title": "de duckdb à st_to_sf",
    "section": "",
    "text": "Jusqu’à récemment, générer un dataframe SF à partir d’une requête duckdb imposait :\nAvec les versions récentes de duckdb, de l’extension spatial et du package geoarrow, vous pouvez lui demander de générer une donnée réutilisable directement par geoarrow :\nlibrary(geoarrow)\nlibrary(duckdb)\nlibrary(sf)\n\ncon &lt;- dbConnect(duckdb())\n\nurl &lt;- \"https://static.data.gouv.fr/resources/sirene-geolocalise-parquet/20240107-143656/sirene2024-geo.parquet\"\n\nx &lt;- dbExecute(con, \"LOAD spatial;\")\nx &lt;- dbExecute(con, \"LOAD httpfs;\")\n1x &lt;- dbExecute(con, \"CALL register_geoarrow_extensions()\")\n\ndplyr::tbl(con, dplyr::sql(glue::glue(\"SELECT geometry \n                                       FROM read_parquet('{url}')\n2                                       LIMIT 5\"))) |&gt;\n3  arrow::to_arrow() |&gt;\n4  st_as_sf(crs=st_crs(2154))\n\n\n1\n\ndemande à duckdb spatial d’ajouter les métadonnées geoarrow dans les colonnes de type géométrie\n\n2\n\ngrace à la commande précédente, cette ligne va retourner des géométries lisibles par geoarrow\n\n3\n\ncette ligne transforme l’objet en un objet arrow\n\n4\n\ngeoarrow surcharge la fonction st_as_sf pour qu’elle puisse lire directement l’objet arrow\n\n\n\n\nSimple feature collection with 5 features and 0 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.735375 ymin: 49.38698 xmax: 3.738175 ymax: 49.39506\nProjected CRS: RGF93 v1 / Lambert-93\n                   geometry\n1 POINT (3.738175 49.39245)\n2 POINT (3.735375 49.38829)\n3 POINT (3.735446 49.39507)\n4 POINT (3.738132 49.38698)\n5 POINT (3.735748 49.38712)"
  },
  {
    "objectID": "posts/2025-07-10-st_as_sf/index.html#une-comparaison-rapide",
    "href": "posts/2025-07-10-st_as_sf/index.html#une-comparaison-rapide",
    "title": "de duckdb à st_to_sf",
    "section": "Une comparaison rapide",
    "text": "Une comparaison rapide\nEt c’est beaucoup plus rapide que toutes les autres méthodes :\n\n\nMontre moi le code du benchmark\nlibrary(arrow)\nlibrary(duckdb)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(timemoir)\nlibrary(geoarrow)\n\nsample_size &lt;- 1e8\n\nif (!file.exists(\"geo.parquet\")) {\n  download.file(\"https://static.data.gouv.fr/resources/sirene-geolocalise-parquet/20240107-143656/sirene2024-geo.parquet\", \"geo.parquet\")\n}\n\nwith_register_geoarrow &lt;- function() {\n  conn_ddb &lt;- dbConnect(duckdb())\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  dbExecute(conn_ddb, \"CALL register_geoarrow_extensions()\")\n  \n  query &lt;- dplyr::tbl(conn_ddb, sql(glue(\"SELECT * FROM read_parquet('geo.parquet') LIMIT {sample_size}\"))) |&gt;\n    arrow::to_arrow() |&gt;\n    st_as_sf(crs=st_crs(2154))\n  \n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_st_read &lt;- function() {\n  conn_ddb &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  a &lt;- st_read(\n    conn_ddb, \n    query=glue(\n      \"SELECT * REPLACE(geometry.ST_ASWKB() AS geometry) FROM read_parquet('geo.parquet') \n      WHERE geometry IS NOT NULL LIMIT {sample_size}\"\n    ), \n    geometry_column = \"geometry\") |&gt;\n    st_set_crs(2154)\n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_get_query_aswkb &lt;- function() {\n  conn_ddb &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  query &lt;- dbGetQuery(\n    conn_ddb, \n    glue(\n      \"\n      SELECT * REPLACE(geometry.ST_ASWKB() AS geometry) FROM read_parquet('geo.parquet') \n      WHERE geometry IS NOT NULL LIMIT {sample_size}\n      \"\n    )\n  ) |&gt;\n    sf::st_as_sf(crs = st_crs(2154))\n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_get_query_astxt &lt;- function() {\n  conn_ddb &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  query &lt;- dbGetQuery(\n    conn_ddb, \n    glue(\n      \"\n      SELECT * REPLACE(geometry.ST_ASText() AS geometry) FROM read_parquet('geo.parquet')\n      WHERE geometry IS NOT NULL LIMIT {sample_size}\n      \"\n    )\n  ) |&gt;\n    sf::st_as_sf(wkt = \"geometry\", crs = st_crs(2154))\n}\n\n\n\nres &lt;- timemoir(\n  with_register_geoarrow(), \n  with_st_read(),\n  with_get_query_aswkb(),\n  with_get_query_astxt())\nres |&gt;\n  kableExtra::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nfname\nduration\nerror\nstart_mem\nmax_mem\ncpu_user\ncpu_sys\n\n\n\n\nwith_register_geoarrow()\n41.378\nNA\n255304\n26963376\n36.374\n6.016\n\n\nwith_st_read()\n202.641\nNA\n255272\n25284744\n192.910\n10.382\n\n\nwith_get_query_aswkb()\n203.976\nNA\n257732\n25283144\n193.012\n11.819\n\n\nwith_get_query_astxt()\n165.089\nNA\n281832\n24851760\n175.733\n9.077\n\n\n\n\nplot(res)"
  },
  {
    "objectID": "posts/2025-07-10-st_as_sf/index.html#quelques-liens",
    "href": "posts/2025-07-10-st_as_sf/index.html#quelques-liens",
    "title": "de duckdb à st_to_sf",
    "section": "Quelques liens",
    "text": "Quelques liens\nOn ne trouve pas grand chose sur cette commande\n\nUn webinaire du R consortium\nUn ticket de geoarrow\n\n\n\n\n\n\n\nInformation de session\n\n\n\n\n\n\ndevtools::session_info(pkgs = \"attached\")\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.0 (2025-04-11)\n os       Ubuntu 22.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Etc/UTC\n date     2025-07-14\n pandoc   3.7.0.2 @ /usr/bin/ (via rmarkdown)\n quarto   1.7.31 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package  * version date (UTC) lib source\n DBI      * 1.2.3   2024-06-02 [1] RSPM (R 4.5.0)\n duckdb   * 1.3.0   2025-06-02 [1] RSPM (R 4.5.0)\n geoarrow * 0.3.0   2025-05-26 [1] RSPM (R 4.5.0)\n sf       * 1.0-21  2025-05-15 [1] RSPM (R 4.5.0)\n\n [1] /usr/local/lib/R/site-library\n [2] /usr/local/lib/R/library\n * ── Packages attached to the search path.\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2025-07-10-to_arrow_bad/index.html",
    "href": "posts/2025-07-10-to_arrow_bad/index.html",
    "title": "Pourquoi éviter arrow::to_arrow() avec DuckDB + dplyr",
    "section": "",
    "text": "Une syntaxe souvent recommandée pour écrire un fichier parquet après des ordres dplyr::tbl est d’utiliser arrow::to_arrow avec arrow::write_dataset ou arrow::write_parquet :\ntbl(con, \"read_parquet('geo.parquet')\") |&gt;\n  ...\n  arrow::to_arrow() |&gt;\n  arrow::write_dataset(\"mon_dataset\")\nCette syntaxe fonctionne toujours mais le nouveau package duckplyr propose une méthode beaucoup plus efficace :\ncon &lt;- dbConnect(duckdb())\n\ntbl(con, \"read_parquet('geo.parquet')\") |&gt;\n  ...\n1  duckplyr::as_duckdb_tibble() |&gt;\n2  duckplyr::compute_parquet(\"my_tbl.parquet\")\n\n\n1\n\nconverti l’objet retourné par tbl en objet lisible par duckplyr\n\n2\n\nécrit le fichier parquet\nLes deux lignes fonctionnent de la même façon que celle de arrow en étant beaucoup plus efficace."
  },
  {
    "objectID": "posts/2025-07-10-to_arrow_bad/index.html#une-comparaison-rapide",
    "href": "posts/2025-07-10-to_arrow_bad/index.html#une-comparaison-rapide",
    "title": "Pourquoi éviter arrow::to_arrow() avec DuckDB + dplyr",
    "section": "Une comparaison rapide",
    "text": "Une comparaison rapide\nVoici les résultats de tests de différentes façons de faire classiques (et le code pour les relancer chez vous ci-dessous) :\n\nwith_arrow : la méthode utilisant arrow\nwith_duckplyr : la méthode utilisant duckplyr\nwith_copy_to : la méthode utilisant le COPY ... TO ... de duckdb à titre de comparaison\n\n\n\nMontre moi le code du benchmark\nlibrary(duckdb)\nlibrary(dplyr)\nlibrary(arrow)\n# pour afficher\nlibrary(kableExtra)\n# un outil de benchmark\nlibrary(timemoir)\n\nif (!file.exists(\"geo.parquet\")) {\n  download.file(\"https://static.data.gouv.fr/resources/sirene-geolocalise-parquet/20240107-143656/sirene2024-geo.parquet\", \"geo.parquet\")\n}\n\n# la version full duckdb\nwith_copy_to &lt;- function() {\n  con &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(con, shutdown = TRUE))\n  \n  dbExecute(con, \"COPY (FROM read_parquet('geo.parquet')) TO 'test.parquet' (FORMAT PARQUET, COMPRESSION ZSTD)\")\n}\n\n# La version `\"historique\" avec `arrow` :\nwith_arrow &lt;- function() {\n  con &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(con, shutdown = TRUE))\n\n  tbl(con, \"read_parquet('geo.parquet')\") |&gt;\n    arrow::to_arrow() |&gt;\n    arrow::write_dataset('test', compression='zstd')\n}\n\n# Et la même en utilisant le nouveau package duckplyr :\nwith_duckplyr &lt;- function() {\n  con &lt;- dbConnect(duckdb())\n  on.exit(dbDisconnect(con, shutdown = TRUE))\n\n  tbl(con, \"read_parquet('geo.parquet')\") |&gt;\n    duckplyr::as_duckdb_tibble() |&gt;\n    duckplyr::compute_parquet(\"my_tbl.parquet\")\n}\n\n\n\nres &lt;- timemoir(\n  with_arrow(), \n  with_copy_to(), \n  with_duckplyr()\n)\nres |&gt;\n  kableExtra::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nfname\nduration\nerror\nstart_mem\nmax_mem\ncpu_user\ncpu_sys\n\n\n\n\nwith_arrow()\n61.147\nNA\n149664\n21835576\n76.045\n17.691\n\n\nwith_copy_to()\n7.480\nNA\n149104\n9096224\n66.407\n9.944\n\n\nwith_duckplyr()\n7.013\nNA\n149104\n11818744\n54.990\n10.564\n\n\n\n\nplot(res)\n\n\n\n\n\n\n\n\n\nSur le serveur que j’utilise, la version duckplyr est 6 fois plus rapide que la version arrow et consomme deux fois moins de mémoire, à égalité avec la méthode pure duckdb."
  },
  {
    "objectID": "posts/2025-07-10-to_arrow_bad/index.html#conclusion",
    "href": "posts/2025-07-10-to_arrow_bad/index.html#conclusion",
    "title": "Pourquoi éviter arrow::to_arrow() avec DuckDB + dplyr",
    "section": "Conclusion",
    "text": "Conclusion\nSi vous utilisez dplyr, arrêtez d’utiliser to_arrow et passez à duckplyr"
  },
  {
    "objectID": "posts/2025-07-10-to_arrow_bad/index.html#quelques-liens",
    "href": "posts/2025-07-10-to_arrow_bad/index.html#quelques-liens",
    "title": "Pourquoi éviter arrow::to_arrow() avec DuckDB + dplyr",
    "section": "Quelques liens",
    "text": "Quelques liens\n\nla documentation de duckplyr\n\n\n\n\n\n\n\n\nInformation de session\n\n\n\n\n\n\ndevtools::session_info(pkgs = \"attached\")\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.0 (2025-04-11)\n os       Ubuntu 22.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Etc/UTC\n date     2025-07-14\n pandoc   3.7.0.2 @ /usr/bin/ (via rmarkdown)\n quarto   1.7.31 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package    * version    date (UTC) lib source\n arrow      * 20.0.0.2   2025-05-26 [1] RSPM (R 4.5.0)\n DBI        * 1.2.3      2024-06-02 [1] RSPM (R 4.5.0)\n dplyr      * 1.1.4      2023-11-17 [1] RSPM (R 4.5.0)\n duckdb     * 1.3.0      2025-06-02 [1] RSPM (R 4.5.0)\n kableExtra * 1.4.0      2024-01-24 [1] RSPM (R 4.5.0)\n timemoir   * 0.7.0.9000 2025-07-14 [1] Github (nbc/timemoir@01b6674)\n\n [1] /usr/local/lib/R/site-library\n [2] /usr/local/lib/R/library\n * ── Packages attached to the search path.\n\n──────────────────────────────────────────────────────────────────────────────"
  }
]