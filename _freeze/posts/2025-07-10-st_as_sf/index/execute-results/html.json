{
  "hash": "fd38e31e9524284fd2aeed6be1438fa9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"de duckdb à st_to_sf\"\ndescription: \"Comment convertir une extraction de duckdb en objet `sf`\"\ndate: 2025-07-12\ncategories: [duckdb, arrow, sf, geoarrow]\nimage: https://duckdb.org/images/logo-dl/DuckDB_Logo-horizontal.svg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\nJusqu'à récemment, générer un dataframe SF à partir d'une requête duckdb imposait :\n\n1. d'utiliser `ST_AsWKB` ou `ST_AsText` sur la colonne géométrie\n2. de matérialiser les données pour les transférer à `sf::st_as_sf`\n\nAvec les versions récentes de duckdb, de l'extension spatial et du package geoarrow, vous pouvez lui demander de générer une donnée réutilisable directement par `geoarrow` : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geoarrow)\nlibrary(duckdb)\nlibrary(sf)\n\ncon <- dbConnect(duckdb())\n\nurl <- \"https://static.data.gouv.fr/resources/sirene-geolocalise-parquet/20240107-143656/sirene2024-geo.parquet\"\n\nx <- dbExecute(con, \"LOAD spatial;\")\nx <- dbExecute(con, \"LOAD httpfs;\")\nx <- dbExecute(con, \"CALL register_geoarrow_extensions()\") # <1>\n\ndplyr::tbl(con, dplyr::sql(glue::glue(\"SELECT geometry \n                                       FROM read_parquet('{url}')\n                                       LIMIT 5\"))) |> # <2>\n  arrow::to_arrow() |> # <3>\n  st_as_sf(crs=st_crs(2154)) # <4>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5 features and 0 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.735375 ymin: 49.38698 xmax: 3.738175 ymax: 49.39506\nProjected CRS: RGF93 v1 / Lambert-93\n                   geometry\n1 POINT (3.738175 49.39245)\n2 POINT (3.735375 49.38829)\n3 POINT (3.735446 49.39507)\n4 POINT (3.738132 49.38698)\n5 POINT (3.735748 49.38712)\n```\n\n\n:::\n:::\n\n\n1. demande à duckdb spatial d'ajouter les métadonnées geoarrow dans les colonnes de type géométrie\n2. grace à la commande précédente, cette ligne va retourner des géométries lisibles par geoarrow\n3. cette ligne transforme l'objet en un objet arrow\n4. geoarrow surcharge la fonction `st_as_sf` pour qu'elle puisse lire directement l'objet arrow\n\n## Une comparaison rapide\n\nEt c'est **beaucoup** plus rapide que toutes les autres méthodes : \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Montre moi le code du benchmark\"}\nlibrary(arrow)\nlibrary(duckdb)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(timemoir)\nlibrary(geoarrow)\n\nsample_size <- 1e8\n\nif (!file.exists(\"geo.parquet\")) {\n  download.file(\"https://static.data.gouv.fr/resources/sirene-geolocalise-parquet/20240107-143656/sirene2024-geo.parquet\", \"geo.parquet\")\n}\n\nwith_register_geoarrow <- function() {\n  conn_ddb <- dbConnect(duckdb())\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  dbExecute(conn_ddb, \"CALL register_geoarrow_extensions()\")\n  \n  query <- dplyr::tbl(conn_ddb, sql(glue(\"SELECT * FROM read_parquet('geo.parquet') LIMIT {sample_size}\"))) |>\n    arrow::to_arrow() |>\n    st_as_sf(crs=st_crs(2154))\n  \n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_st_read <- function() {\n  conn_ddb <- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  a <- st_read(\n    conn_ddb, \n    query=glue(\n      \"SELECT * REPLACE(geometry.ST_ASWKB() AS geometry) FROM read_parquet('geo.parquet') \n      WHERE geometry IS NOT NULL LIMIT {sample_size}\"\n    ), \n    geometry_column = \"geometry\") |>\n    st_set_crs(2154)\n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_get_query_aswkb <- function() {\n  conn_ddb <- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  query <- dbGetQuery(\n    conn_ddb, \n    glue(\n      \"\n      SELECT * REPLACE(geometry.ST_ASWKB() AS geometry) FROM read_parquet('geo.parquet') \n      WHERE geometry IS NOT NULL LIMIT {sample_size}\n      \"\n    )\n  ) |>\n    sf::st_as_sf(crs = st_crs(2154))\n  dbDisconnect(conn_ddb, shutdown = TRUE)\n}\n\nwith_get_query_astxt <- function() {\n  conn_ddb <- dbConnect(duckdb())\n  on.exit(dbDisconnect(conn_ddb, shutdown = TRUE))\n  dbExecute(conn_ddb, \"LOAD spatial;\")\n  \n  query <- dbGetQuery(\n    conn_ddb, \n    glue(\n      \"\n      SELECT * REPLACE(geometry.ST_ASText() AS geometry) FROM read_parquet('geo.parquet')\n      WHERE geometry IS NOT NULL LIMIT {sample_size}\n      \"\n    )\n  ) |>\n    sf::st_as_sf(wkt = \"geometry\", crs = st_crs(2154))\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- timemoir(\n  with_register_geoarrow(), \n  with_st_read(),\n  with_get_query_aswkb(),\n  with_get_query_astxt())\n```\n\n```{.r .cell-code}\nres |>\n  kableExtra::kable()\n```\n\n::: {.cell-output-display}\n\n\n|fname                    | duration|error | start_mem|  max_mem| cpu_user| cpu_sys|\n|:------------------------|--------:|:-----|---------:|--------:|--------:|-------:|\n|with_register_geoarrow() |   41.378|NA    |    255304| 26963376|   36.374|   6.016|\n|with_st_read()           |  202.641|NA    |    255272| 25284744|  192.910|  10.382|\n|with_get_query_aswkb()   |  203.976|NA    |    257732| 25283144|  193.012|  11.819|\n|with_get_query_astxt()   |  165.089|NA    |    281832| 24851760|  175.733|   9.077|\n\n\n:::\n\n```{.r .cell-code}\nplot(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/output_benchmark-1.png){width=672}\n:::\n:::\n\n\n## Quelques liens\n\nOn ne trouve pas grand chose sur cette commande \n\n* [Un webinaire du R consortium](https://youtu.be/tjNEoIYr_ag?t=1641)\n* [Un ticket de geoarrow](https://github.com/duckdb/duckdb-spatial/issues/589)\n\n::: {.callout-note collapse=true}\n## Information de session\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::session_info(pkgs = \"attached\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.0 (2025-04-11)\n os       Ubuntu 22.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Etc/UTC\n date     2025-07-14\n pandoc   3.7.0.2 @ /usr/bin/ (via rmarkdown)\n quarto   1.7.31 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package  * version date (UTC) lib source\n DBI      * 1.2.3   2024-06-02 [1] RSPM (R 4.5.0)\n duckdb   * 1.3.0   2025-06-02 [1] RSPM (R 4.5.0)\n geoarrow * 0.3.0   2025-05-26 [1] RSPM (R 4.5.0)\n sf       * 1.0-21  2025-05-15 [1] RSPM (R 4.5.0)\n\n [1] /usr/local/lib/R/site-library\n [2] /usr/local/lib/R/library\n * ── Packages attached to the search path.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}